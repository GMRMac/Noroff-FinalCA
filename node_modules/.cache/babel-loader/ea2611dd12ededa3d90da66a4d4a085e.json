{"ast":null,"code":"import _slicedToArray from \"D:\\\\OneDrive\\\\Noroff\\\\2018-2020_Secound year\\\\07_JavaScript Frameworks 2\\\\Module 1\\\\module itself\\\\Noroff-FinalCA\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { createContext, useContext, createElement, useMemo, useState as useState$1, useEffect as useEffect$1, useRef as useRef$1, isValidElement, cloneElement, Fragment } from 'react';\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nconst RADIO_INPUT = 'radio';\nconst FILE_INPUT = 'file';\nconst VALUE = 'value';\nconst UNDEFINED = 'undefined';\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\n\nfunction attachEventListeners({\n  field,\n  handleChange,\n  isRadioOrCheckbox\n}) {\n  const ref = field.ref;\n\n  if (ref.addEventListener) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isUndefined = val => val === undefined;\n\nvar isNullOrUndefined = value => value === null || isUndefined(value);\n\nvar isArray = value => Array.isArray(value);\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nconst isKey = value => !isArray(value) && (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\n    result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (REGEX_IS_DEEP_PROP.test(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nvar isRadioInput = type => type === RADIO_INPUT;\n\nvar isCheckBoxInput = type => type === 'checkbox';\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\n  if (!field) {\n    return;\n  }\n\n  const ref = field.ref,\n        _field$ref = field.ref,\n        name = _field$ref.name,\n        type = _field$ref.type,\n        mutationWatcher = field.mutationWatcher;\n\n  if (!type) {\n    return;\n  }\n\n  const fieldValue = fields[name];\n\n  if ((isRadioInput(type) || isCheckBoxInput(type)) && fieldValue) {\n    const options = fieldValue.options;\n\n    if (isArray(options) && options.length) {\n      options.forEach(({\n        ref\n      }, index) => {\n        if (ref && isDetached(ref) || forceDelete) {\n          const mutationWatcher = ref.mutationWatcher;\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          options.splice(index, 1);\n        }\n      });\n\n      if (options && !options.length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fields[name];\n  }\n}\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, {\n  ref: {\n    checked,\n    value\n  }\n}) => checked ? {\n  isValid: true,\n  value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isFileInput = type => type === FILE_INPUT;\n\nvar isMultipleSelect = type => type === 'select-multiple';\n\nvar isEmptyString = value => value === '';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(({\n        ref: {\n          checked\n        }\n      }) => checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const _options$0$ref = options[0].ref,\n          checked = _options$0$ref.checked,\n          value = _options$0$ref.value,\n          attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fields, ref) {\n  const type = ref.type,\n        name = ref.name,\n        options = ref.options,\n        value = ref.value,\n        files = ref.files;\n  const field = fields[name];\n\n  if (isFileInput(type)) {\n    return files;\n  }\n\n  if (isRadioInput(type)) {\n    return field ? getRadioValue(field.options).value : '';\n  }\n\n  if (isMultipleSelect(type)) {\n    return getMultipleSelectValue(options);\n  }\n\n  if (isCheckBoxInput(type)) {\n    return field ? getCheckboxValue(field.options).value : false;\n  }\n\n  return value;\n}\n\nvar getFieldsValues = fields => Object.values(fields).reduce((previous, {\n  ref,\n  ref: {\n    name\n  }\n}) => Object.assign(Object.assign({}, previous), {\n  [name]: getFieldValue(fields, ref)\n}), {});\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isSameError = (error, type, message) => isObject(error) && error.type === type && error.message === message;\n\nvar get = (obj, path, defaultValue) => {\n  const result = path.split(/[,[\\].]+?/).filter(Boolean).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? obj[path] || defaultValue : result;\n};\n\nfunction shouldUpdateWithError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name) || existFieldError && existFieldError.isManual) {\n    return false;\n  }\n\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError.type, currentFieldError.message);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nvar getValueAndMessage = validationData => {\n  const isPureObject = isObject(validationData) && !isRegex(validationData);\n  return {\n    value: isPureObject ? validationData.value : validationData,\n    message: isPureObject ? validationData.message : ''\n  };\n};\n\nvar isString = value => typeof value === 'string';\n\nvar isFunction = value => typeof value === 'function';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction getValidateError(result, ref, type = 'validate') {\n  const isStringValue = isString(result);\n\n  if (isStringValue || isBoolean(result) && !result) {\n    const message = isStringValue ? result : '';\n    return {\n      type,\n      message,\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (!validateAllFieldCriteria) {\n    return {};\n  }\n\n  const error = errors[name];\n  return Object.assign(Object.assign({}, error), {\n    types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n      [type]: message || true\n    })\n  });\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, {\n  ref,\n  ref: {\n    type,\n    value,\n    name,\n    valueAsNumber,\n    valueAsDate\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}) => {\n  const fields = fieldsRef.current;\n  const error = {};\n  const isRadio = isRadioInput(type);\n  const isCheckBox = isCheckBoxInput(type);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = isEmptyString(value);\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n\n    if (!validateAllFieldCriteria) {\n      return error;\n    }\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const message = isString(required) ? required : getValueAndMessage(required).message;\n    error[name] = Object.assign({\n      type: INPUT_VALIDATION_RULES.required,\n      message,\n      ref: isRadioOrCheckbox ? fields[name].options[0].ref : ref\n    }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n    if (!validateAllFieldCriteria) {\n      return error;\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n\n    const _getValueAndMessage = getValueAndMessage(max),\n          maxValue = _getValueAndMessage.value,\n          maxMessage = _getValueAndMessage.message;\n\n    const _getValueAndMessage2 = getValueAndMessage(min),\n          minValue = _getValueAndMessage2.value,\n          minMessage = _getValueAndMessage2.message;\n\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = valueAsDate || new Date(value);\n\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const _getValueAndMessage3 = getValueAndMessage(maxLength),\n          maxLengthValue = _getValueAndMessage3.value,\n          maxLengthMessage = _getValueAndMessage3.message;\n\n    const _getValueAndMessage4 = getValueAndMessage(minLength),\n          minLengthValue = _getValueAndMessage4.value,\n          minLengthMessage = _getValueAndMessage4.message;\n\n    const inputLength = value.toString().length;\n    const exceedMax = maxLength && inputLength > maxLengthValue;\n    const exceedMin = minLength && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const _getValueAndMessage5 = getValueAndMessage(pattern),\n          patternValue = _getValueAndMessage5.value,\n          patternMessage = _getValueAndMessage5.message;\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fields, ref);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      const validateFunctions = Object.entries(validate);\n      const validationResult = await new Promise(resolve => {\n        validateFunctions.reduce(async (previous, [key, validate], index) => {\n          if (!isEmptyObject((await previous)) && !validateAllFieldCriteria || !isFunction(validate)) {\n            return resolve(previous);\n          }\n\n          let result;\n          const validateResult = await validate(fieldValue);\n          const validateError = getValidateError(validateResult, validateRef, key);\n\n          if (validateError) {\n            result = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              error[name] = result;\n            }\n          } else {\n            result = previous;\n          }\n\n          return validateFunctions.length - 1 === index ? resolve(result) : result;\n        }, {});\n      });\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner) ? error.inner.reduce((previous, {\n  path,\n  message,\n  type\n}) => Object.assign(Object.assign({}, previous), previous[path] && validateAllFieldCriteria ? {\n  [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message)\n} : {\n  [path]: previous[path] || Object.assign({\n    message,\n    type\n  }, validateAllFieldCriteria ? {\n    types: {\n      [type]: message || true\n    }\n  } : {})\n}), {}) : {\n  [error.path]: {\n    message: error.message,\n    type: error.type\n  }\n};\n\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data) {\n  try {\n    return {\n      values: await validationSchema.validate(data, {\n        abortEarly: false\n      }),\n      errors: {}\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria))\n    };\n  }\n}\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name]) ? get(defaultValues, name, defaultValue) : defaultValues[name];\n\nfunction flatArray(list) {\n  return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\n}\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return isArray(values) ? values.map((value, key) => getInnerPath(value, key)) : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\n};\n\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, combinedDefaultValues) => {\n  let value;\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    watchFields.add(fieldName);\n    value = fieldValues[fieldName];\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isObject(combinedDefaultValues) ? getDefaultValue(combinedDefaultValues, fieldName) : combinedDefaultValues : value;\n};\n\nvar skipValidation = ({\n  hasError,\n  isBlurEvent,\n  isOnSubmit,\n  isReValidateOnSubmit,\n  isOnBlur,\n  isReValidateOnBlur,\n  isSubmitted\n}) => isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n\nconst isMatchFieldArrayName = (name, searchName) => name.startsWith(\"\".concat(searchName, \"[\"));\n\nvar isNameInFieldArray = (names, name) => [...names].reduce((prev, current) => isMatchFieldArrayName(name, current) ? true : prev, false);\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst omitObject = (obj, key) => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const _a = key,\n        omitted = obj[_a],\n        rest = __rest(obj, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\n\n  return rest;\n};\n\nconst unsetObject = target => {\n  for (const key in target) {\n    const data = target[key];\n    const isArrayObject = isArray(data);\n\n    if ((isObject(data) || isArrayObject) && !data.ref) {\n      unsetObject(data);\n    }\n\n    if (isUndefined(data) || isEmptyObject(data) || isArrayObject && !target[key].filter(Boolean).length) {\n      delete target[key];\n    }\n  }\n\n  return target;\n};\n\nconst unset = (target, paths) => {\n  paths.forEach(path => {\n    set(target, path, undefined);\n  });\n  return unsetObject(target);\n};\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange\n});\n\nconst useRef = React.useRef,\n      useState = React.useState,\n      useCallback = React.useCallback,\n      useEffect = React.useEffect;\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  validationSchema,\n  defaultValues = {},\n  submitFocusError = true,\n  validateCriteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const validateAllFieldCriteria = validateCriteriaMode === 'all';\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const dirtyFieldsRef = useRef(new Set());\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultRenderValuesRef = useRef({});\n  const defaultValuesRef = useRef(defaultValues);\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const resetFieldArrayFunctionRef = useRef({});\n  const fieldArrayNamesRef = useRef(new Set());\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        render = _useState2[1];\n\n  const _useRef$current = useRef(modeChecker(mode)).current,\n        isOnBlur = _useRef$current.isOnBlur,\n        isOnSubmit = _useRef$current.isOnSubmit;\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb && 'Proxy' in window;\n  const readFormState = useRef({\n    dirty: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const _useRef$current2 = useRef(modeChecker(reValidateMode)).current,\n        isReValidateOnBlur = _useRef$current2.isOnBlur,\n        isReValidateOnSubmit = _useRef$current2.isOnSubmit;\n  defaultValuesRef.current = defaultValuesRef.current ? defaultValuesRef.current : defaultValues;\n  const reRender = useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  const validateFieldCurry = useCallback(validateField.bind(null, fieldsRef, validateAllFieldCriteria), []);\n  const validateFieldsSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validateAllFieldCriteria), [validationSchema]);\n  const renderBaseOnError = useCallback((name, error, shouldRender, skipReRender) => {\n    let shouldReRender = shouldRender || shouldUpdateWithError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || validationSchema) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || get(errorsRef.current, name);\n      }\n\n      errorsRef.current = unset(errorsRef.current, [name]);\n    } else {\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || !get(errorsRef.current, name);\n      set(errorsRef.current, name, error[name]);\n    }\n\n    if (shouldReRender && !skipReRender) {\n      reRender();\n      return true;\n    }\n  }, [reRender, validationSchema]);\n  const setFieldValue = useCallback((name, rawValue) => {\n    const field = fieldsRef.current[name];\n\n    if (!field) {\n      return false;\n    }\n\n    const ref = field.ref;\n    const type = ref.type;\n    const options = field.options;\n    const value = isWeb && ref instanceof window.HTMLElement && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(type) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(type)) {\n      if (value instanceof FileList || value === '') {\n        ref.files = value;\n      } else {\n        ref.value = value;\n      }\n    } else if (isMultipleSelect(type)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(type) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = value.includes(checkboxRef.value)) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n\n    return type;\n  }, [isWeb]);\n\n  const setDirty = name => {\n    if (!fieldsRef.current[name]) {\n      return false;\n    }\n\n    const isDirty = defaultRenderValuesRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\n\n    if (isDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n\n    isDirtyRef.current = !!dirtyFieldsRef.current.size;\n    return isDirtyChanged && readFormState.current.dirty;\n  };\n\n  const setInternalValue = useCallback((name, value) => {\n    setFieldValue(name, value);\n\n    if (setDirty(name) || !get(touchedFieldsRef.current, name) && readFormState.current.touched) {\n      return !!set(touchedFieldsRef.current, name, true);\n    }\n  }, [setFieldValue]);\n  const executeValidation = useCallback(async (name, shouldRender, skipReRender) => {\n    const field = fieldsRef.current[name];\n\n    if (!field) {\n      return false;\n    }\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n    renderBaseOnError(name, error, false, skipReRender);\n    return isEmptyObject(error);\n  }, [reRender, renderBaseOnError, validateAllFieldCriteria]);\n  const executeSchemaValidation = useCallback(async (payload, shouldRender) => {\n    const _ref = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(getFieldsValues(fieldsRef.current))),\n          errors = _ref.errors;\n\n    const previousFormIsValid = isValidRef.current;\n    isValidRef.current = isEmptyObject(errors);\n\n    if (isArray(payload)) {\n      payload.forEach(name => {\n        if (errors[name]) {\n          set(errorsRef.current, name, errors[name]);\n        } else {\n          unset(errorsRef.current, [name]);\n        }\n      });\n      reRender();\n    } else {\n      const fieldName = payload;\n      const error = get(errors, fieldName) ? {\n        [fieldName]: get(errors, fieldName)\n      } : {};\n      renderBaseOnError(fieldName, error, shouldRender || previousFormIsValid !== isValidRef.current);\n    }\n\n    return isEmptyObject(errorsRef.current);\n  }, [reRender, renderBaseOnError, validateAllFieldCriteria, validationSchema]);\n  const triggerValidation = useCallback(async (payload, shouldRender) => {\n    const fields = payload || Object.keys(fieldsRef.current);\n\n    if (validationSchema) {\n      return executeSchemaValidation(fields, shouldRender);\n    }\n\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, false, true)));\n      reRender();\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields, shouldRender);\n  }, [executeSchemaValidation, executeValidation, reRender, validationSchema]);\n  const setValue = useCallback((name, value, shouldValidate) => {\n    const shouldRender = setInternalValue(name, value) || isWatchAllRef.current || watchFieldsRef.current.has(name);\n\n    if (shouldValidate) {\n      return triggerValidation(name, shouldRender);\n    }\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    return;\n  }, [reRender, setInternalValue, triggerValidation]);\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({\n    type,\n    target\n  }) => {\n    const name = target ? target.name : '';\n    const fields = fieldsRef.current;\n    const errors = errorsRef.current;\n    const field = fields[name];\n    const currentError = get(errors, name);\n    let error;\n\n    if (!field) {\n      return;\n    }\n\n    const isBlurEvent = type === EVENTS.BLUR;\n    const shouldSkipValidation = skipValidation({\n      hasError: !!currentError,\n      isBlurEvent,\n      isOnSubmit,\n      isReValidateOnSubmit,\n      isOnBlur,\n      isReValidateOnBlur,\n      isSubmitted: isSubmittedRef.current\n    });\n    const shouldUpdateDirty = setDirty(name);\n    let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current.has(name) || shouldUpdateDirty;\n\n    if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormState.current.touched) {\n      set(touchedFieldsRef.current, name, true);\n      shouldUpdateState = true;\n    }\n\n    if (shouldSkipValidation) {\n      return shouldUpdateState && reRender();\n    }\n\n    if (validationSchema) {\n      const _ref2 = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(getFieldsValues(fields))),\n            errors = _ref2.errors;\n\n      const validForm = isEmptyObject(errors);\n      error = get(errors, name) ? {\n        [name]: get(errors, name)\n      } : {};\n\n      if (isValidRef.current !== validForm) {\n        shouldUpdateState = true;\n      }\n\n      isValidRef.current = validForm;\n    } else {\n      error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n    }\n\n    if (!renderBaseOnError(name, error) && shouldUpdateState) {\n      reRender();\n    }\n  };\n  const validateSchemaIsValid = useCallback(() => {\n    const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    validateFieldsSchemaCurry(transformToNestObject(fieldValues)).then(({\n      errors\n    }) => {\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (previousFormIsValid && previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  }, [reRender, validateFieldsSchemaCurry]);\n  const resetFieldRef = useCallback(name => {\n    errorsRef.current = unset(errorsRef.current, [name]);\n    touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\n    fieldsRef.current = omitObject(fieldsRef.current, name);\n    defaultRenderValuesRef.current = omitObject(defaultRenderValuesRef.current, name);\n    [dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(data => data.current.delete(name));\n\n    if (readFormState.current.isValid || readFormState.current.touched) {\n      reRender();\n    }\n\n    if (validationSchema) {\n      validateSchemaIsValid();\n    }\n  }, [reRender]);\n  const removeEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (!field) {\n      return;\n    }\n\n    if (!isUndefined(handleChangeRef.current)) {\n      findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\n    }\n\n    resetFieldRef(field.ref.name);\n  }, [resetFieldRef]);\n\n  function clearError(name) {\n    if (isUndefined(name)) {\n      errorsRef.current = {};\n    } else {\n      (isArray(name) ? name : [name]).forEach(fieldName => errorsRef.current = omitObject(errorsRef.current, fieldName));\n    }\n\n    reRender();\n  }\n\n  const setInternalError = ({\n    name,\n    type,\n    types,\n    message,\n    preventRender\n  }) => {\n    const field = fieldsRef.current[name];\n\n    if (!isSameError(errorsRef.current[name], type, message)) {\n      set(errorsRef.current, name, {\n        type,\n        types,\n        message,\n        ref: field ? field.ref : {},\n        isManual: true\n      });\n\n      if (!preventRender) {\n        reRender();\n      }\n    }\n  };\n\n  function setError(name, type = '', message) {\n    if (isString(name)) {\n      setInternalError(Object.assign({\n        name\n      }, isObject(type) ? {\n        types: type,\n        type: ''\n      } : {\n        type,\n        message\n      }));\n    } else if (isArray(name)) {\n      name.forEach(error => setInternalError(Object.assign(Object.assign({}, error), {\n        preventRender: true\n      })));\n      reRender();\n    }\n  }\n\n  function watch(fieldNames, defaultValue) {\n    const combinedDefaultValues = isUndefined(defaultValue) ? isUndefined(defaultValuesRef.current) ? {} : defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const watchFields = watchFieldsRef.current;\n\n    if (isProxyEnabled) {\n      readFormState.current.dirty = true;\n    }\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => {\n        let value;\n\n        if (isEmptyObject(fieldsRef.current) && isObject(combinedDefaultValues)) {\n          value = getDefaultValue(combinedDefaultValues, name);\n        } else {\n          value = assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues);\n        }\n\n        return Object.assign(Object.assign({}, previous), {\n          [name]: value\n        });\n      }, {});\n    }\n\n    isWatchAllRef.current = true;\n    const result = !isEmptyObject(fieldValues) && fieldValues || defaultValue || defaultValuesRef.current;\n    return fieldNames && fieldNames.nest ? transformToNestObject(result) : result;\n  }\n\n  function unregister(names) {\n    if (!isEmptyObject(fieldsRef.current)) {\n      (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\n    }\n  }\n\n  function registerFieldsRef(ref, validateOptions = {}) {\n    if (!ref.name) {\n      return console.warn('Missing name @', ref);\n    }\n\n    const name = ref.name,\n          type = ref.type,\n          value = ref.value;\n    const fieldAttributes = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioInput(type) || isCheckBoxInput(type);\n    let currentField = fields[name];\n\n    if (isRadioOrCheckbox ? currentField && isArray(currentField.options) && currentField.options.find(({\n      ref\n    }) => value === ref.value) : currentField) {\n      fields[name] = Object.assign(Object.assign({}, currentField), validateOptions);\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\n\n      if (isRadioOrCheckbox) {\n        currentField = Object.assign({\n          options: [...(currentField && currentField.options || []), {\n            ref,\n            mutationWatcher\n          }],\n          ref: {\n            type,\n            name\n          }\n        }, validateOptions);\n      } else {\n        currentField = Object.assign(Object.assign({}, fieldAttributes), {\n          mutationWatcher\n        });\n      }\n    } else {\n      currentField = fieldAttributes;\n    }\n\n    fields[name] = currentField;\n\n    if (!isEmptyObject(defaultValuesRef.current)) {\n      const defaultValue = getDefaultValue(defaultValuesRef.current, name);\n\n      if (!isUndefined(defaultValue) && !isNameInFieldArray(fieldArrayNamesRef.current, name)) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (validationSchema && readFormState.current.isValid) {\n      validateSchemaIsValid();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormState.current.isValid) {\n        validateFieldCurry(currentField).then(error => {\n          const previousFormIsValid = isValidRef.current;\n\n          if (isEmptyObject(error)) {\n            validFieldsRef.current.add(name);\n          } else {\n            isValidRef.current = false;\n          }\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (!defaultRenderValuesRef.current[name]) {\n      defaultRenderValuesRef.current[name] = getFieldValue(fields, currentField.ref);\n    }\n\n    if (!type) {\n      return;\n    }\n\n    const fieldToAttachListener = isRadioOrCheckbox && currentField.options ? currentField.options[currentField.options.length - 1] : currentField;\n    attachEventListeners({\n      field: fieldToAttachListener,\n      isRadioOrCheckbox,\n      handleChange: handleChangeRef.current\n    });\n  }\n\n  function register(refOrValidationOptions, validationOptions) {\n    if (isWindowUndefined || !refOrValidationOptions) {\n      return;\n    }\n\n    if (isString(refOrValidationOptions)) {\n      registerFieldsRef({\n        name: refOrValidationOptions\n      }, validationOptions);\n      return;\n    }\n\n    if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n      registerFieldsRef(refOrValidationOptions, validationOptions);\n      return;\n    }\n\n    return ref => ref && registerFieldsRef(ref, refOrValidationOptions);\n  }\n\n  const handleSubmit = useCallback(callback => async e => {\n    if (e) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors;\n    let fieldValues;\n    const fields = fieldsRef.current;\n\n    if (readFormState.current.isSubmitting) {\n      isSubmittingRef.current = true;\n      reRender();\n    }\n\n    try {\n      if (validationSchema) {\n        fieldValues = getFieldsValues(fields);\n\n        const _ref3 = await validateFieldsSchemaCurry(transformToNestObject(fieldValues)),\n              errors = _ref3.errors,\n              values = _ref3.values;\n\n        errorsRef.current = errors;\n        fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        const _ref4 = await Object.values(fields).reduce(async (previous, field) => {\n          if (!field) {\n            return previous;\n          }\n\n          const resolvedPrevious = await previous;\n          const ref = field.ref,\n                name = field.ref.name;\n\n          if (!fields[name]) {\n            return Promise.resolve(resolvedPrevious);\n          }\n\n          const fieldError = await validateFieldCurry(field);\n\n          if (fieldError[name]) {\n            set(resolvedPrevious.errors, name, fieldError[name]);\n            validFieldsRef.current.delete(name);\n            return Promise.resolve(resolvedPrevious);\n          }\n\n          if (fieldsWithValidationRef.current.has(name)) {\n            validFieldsRef.current.add(name);\n          }\n\n          resolvedPrevious.values[name] = getFieldValue(fields, ref);\n          return Promise.resolve(resolvedPrevious);\n        }, Promise.resolve({\n          errors: {},\n          values: {}\n        })),\n              errors = _ref4.errors,\n              values = _ref4.values;\n\n        fieldErrors = errors;\n        fieldValues = values;\n      }\n\n      if (isEmptyObject(fieldErrors)) {\n        errorsRef.current = {};\n        await callback(transformToNestObject(fieldValues), e);\n      } else {\n        if (submitFocusError) {\n          for (const key in fieldsRef.current) {\n            if (get(fieldErrors, key)) {\n              const field = fieldsRef.current[key];\n\n              if (field) {\n                if (field.ref.focus) {\n                  field.ref.focus();\n                  break;\n                } else if (field.options) {\n                  field.options[0].ref.focus();\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        errorsRef.current = fieldErrors;\n      }\n    } finally {\n      isSubmittedRef.current = true;\n      isSubmittingRef.current = false;\n      submitCountRef.current = submitCountRef.current + 1;\n      reRender();\n    }\n  }, [reRender, submitFocusError, validateFieldCurry, validateFieldsSchemaCurry, validationSchema]);\n\n  const resetRefs = () => {\n    errorsRef.current = {};\n    fieldsRef.current = {};\n    touchedFieldsRef.current = {};\n    validFieldsRef.current = new Set();\n    fieldsWithValidationRef.current = new Set();\n    defaultRenderValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    dirtyFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    isSubmittedRef.current = false;\n    isDirtyRef.current = false;\n    isValidRef.current = true;\n    submitCountRef.current = 0;\n  };\n\n  const reset = values => {\n    for (const value of Object.values(fieldsRef.current)) {\n      if (value && value.ref && value.ref.closest) {\n        try {\n          value.ref.closest('form').reset();\n          break;\n        } catch (_a) {}\n      }\n    }\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray(values));\n    resetRefs();\n\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n\n    reRender();\n  };\n\n  const getValues = payload => {\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const outputValues = isEmptyObject(fieldValues) ? defaultValuesRef.current : fieldValues;\n    return payload && payload.nest ? transformToNestObject(outputValues) : outputValues;\n  };\n\n  useEffect(() => () => {\n    isUnMount.current = true;\n    fieldsRef.current && Object.values(fieldsRef.current).forEach(field => removeEventListenerAndRef(field, true));\n  }, [removeEventListenerAndRef]);\n\n  if (!validationSchema) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirty: isDirtyRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isEmptyObject(fieldsRef.current) || isValidRef.current\n  };\n  const control = {\n    register,\n    unregister,\n    setValue,\n    formState,\n    mode: {\n      isOnBlur,\n      isOnSubmit\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    errors: errorsRef.current,\n    fieldsRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    defaultValuesRef\n  };\n  return {\n    watch,\n    control,\n    handleSubmit,\n    setValue,\n    triggerValidation,\n    getValues: useCallback(getValues, []),\n    reset: useCallback(reset, [reRender]),\n    register: useCallback(register, [defaultRenderValuesRef.current, defaultValuesRef.current]),\n    unregister: useCallback(unregister, [removeEventListenerAndRef]),\n    clearError: useCallback(clearError, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (prop in obj) {\n          readFormState.current[prop] = true;\n          return obj[prop];\n        }\n\n        return {};\n      }\n    }) : formState\n  };\n}\n\nconst FormGlobalContext = createContext(null);\n\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\n\nfunction FormContext(_a) {\n  var children = _a.children,\n      formState = _a.formState,\n      errors = _a.errors,\n      restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\n\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restMethods), {\n      formState,\n      errors\n    })\n  }, children);\n}\n\nvar generateId = () => {\n  const d = performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst appendId = value => Object.assign(Object.assign({}, value), {\n  id: generateId()\n});\n\nconst mapIds = data => (isArray(data) ? data : []).map(value => appendId(value));\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  let isMatch = false;\n\n  if (referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n\n  for (let i = 0; i < referenceArray.length; i++) {\n    if (isMatch) {\n      break;\n    }\n\n    const _a = referenceArray[i],\n          data = __rest(_a, [\"id\"]);\n\n    if (!differenceArray[i] || Object.keys(data).length !== Object.keys(differenceArray[i]).length) {\n      isMatch = true;\n      break;\n    }\n\n    for (const key in data) {\n      if (!differenceArray[i][key] || data[key] !== differenceArray[i][key]) {\n        isMatch = true;\n        break;\n      }\n    }\n  }\n\n  return isMatch;\n}\n\nfunction useFieldArray({\n  control,\n  name\n}) {\n  const methods = useFormContext();\n\n  const _ref5 = control || methods.control,\n        resetFieldArrayFunctionRef = _ref5.resetFieldArrayFunctionRef,\n        fieldArrayNamesRef = _ref5.fieldArrayNamesRef,\n        fieldsRef = _ref5.fieldsRef,\n        defaultValuesRef = _ref5.defaultValuesRef,\n        unregister = _ref5.unregister,\n        isDirtyRef = _ref5.isDirtyRef;\n\n  const memoizedDefaultValues = useMemo(() => get(defaultValuesRef.current, name, []), // eslint-disable-next-line react-hooks/exhaustive-deps\n  [name]);\n\n  const _useState$ = useState$1(mapIds(memoizedDefaultValues)),\n        _useState$2 = _slicedToArray(_useState$, 2),\n        fields = _useState$2[0],\n        setField = _useState$2[1];\n\n  const resetFields = flagOrFields => {\n    isDirtyRef.current = isUndefined(flagOrFields) ? true : getIsFieldsDifferent(flagOrFields, memoizedDefaultValues);\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        unregister(key);\n      }\n    }\n  };\n\n  const append = value => {\n    isDirtyRef.current = true;\n    setField([...fields, appendId(value)]);\n  };\n\n  const prepend = value => {\n    resetFields();\n    setField(mapIds([appendId(value), ...fields]));\n  };\n\n  const remove = index => {\n    const data = isUndefined(index) ? [] : [...fields.slice(0, index), ...fields.slice(index + 1)];\n    resetFields(data);\n    setField(mapIds(data));\n  };\n\n  const insert = (index, value) => {\n    resetFields();\n    setField(mapIds([...fields.slice(0, index), appendId(value), ...fields.slice(index)]));\n  };\n\n  const swap = (indexA, indexB) => {\n    var _ref6 = [fields[indexB], fields[indexA]];\n    fields[indexA] = _ref6[0];\n    fields[indexB] = _ref6[1];\n    resetFields(fields);\n    setField(mapIds([...fields]));\n  };\n\n  const move = (from, to) => {\n    fields.splice(to, 0, fields.splice(from, 1)[0]);\n    resetFields(fields);\n    setField(mapIds([...fields]));\n  };\n\n  const reset = values => {\n    resetFields();\n    setField(mapIds(get(values, name)));\n  };\n\n  useEffect$1(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [name]);\n  return {\n    swap,\n    move,\n    prepend,\n    append,\n    remove,\n    insert,\n    fields\n  };\n}\n\nvar getInputValue = (target, isCheckbox) => {\n  if (isNullOrUndefined(target)) {\n    return target;\n  }\n\n  return isCheckbox ? isUndefined(target.checked) ? target : target.checked : isUndefined(target.value) ? target : target.value;\n};\n\nconst Controller = _a => {\n  var name = _a.name,\n      rules = _a.rules,\n      InnerComponent = _a.as,\n      onChange = _a.onChange,\n      onBlur = _a.onBlur,\n      _a$onChangeName = _a.onChangeName,\n      onChangeName = _a$onChangeName === void 0 ? VALIDATION_MODE.onChange : _a$onChangeName,\n      _a$onBlurName = _a.onBlurName,\n      onBlurName = _a$onBlurName === void 0 ? VALIDATION_MODE.onBlur : _a$onBlurName,\n      valueName = _a.valueName,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onChange\", \"onBlur\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\"]);\n\n  const methods = useFormContext();\n\n  const _ref7 = control || methods.control,\n        defaultValuesRef = _ref7.defaultValuesRef,\n        setValue = _ref7.setValue,\n        register = _ref7.register,\n        unregister = _ref7.unregister,\n        errors = _ref7.errors,\n        _ref7$mode = _ref7.mode,\n        isOnSubmit = _ref7$mode.isOnSubmit,\n        isOnBlur = _ref7$mode.isOnBlur,\n        _ref7$reValidateMode = _ref7.reValidateMode,\n        isReValidateOnBlur = _ref7$reValidateMode.isReValidateOnBlur,\n        isReValidateOnSubmit = _ref7$reValidateMode.isReValidateOnSubmit,\n        isSubmitted = _ref7.formState.isSubmitted,\n        fieldsRef = _ref7.fieldsRef,\n        fieldArrayNamesRef = _ref7.fieldArrayNamesRef;\n\n  const _useState$3 = useState$1(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue),\n        _useState$4 = _slicedToArray(_useState$3, 2),\n        value = _useState$4[0],\n        setInputStateValue = _useState$4[1];\n\n  const valueRef = useRef$1(value);\n  const isCheckboxInput = isBoolean(value);\n\n  const shouldValidate = isBlurEvent => !skipValidation({\n    hasError: !!errors[name],\n    isBlurEvent,\n    isOnBlur,\n    isOnSubmit,\n    isReValidateOnBlur,\n    isReValidateOnSubmit,\n    isSubmitted\n  });\n\n  const commonTask = target => {\n    const data = getInputValue(target, isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const eventWrapper = (event, eventName) => (...arg) => {\n    const data = commonTask(event(arg));\n    const isBlurEvent = eventName === EVENTS.BLUR;\n    setValue(name, data, shouldValidate(isBlurEvent));\n  };\n\n  const handleChange = e => {\n    const data = commonTask(e && e.target ? e.target : e);\n    setValue(name, data, shouldValidate());\n  };\n\n  const handleBlur = e => {\n    const data = commonTask(e && e.target ? e.target : e);\n    setValue(name, data, shouldValidate(true));\n  };\n\n  const registerField = () => register(Object.defineProperty({\n    name\n  }, VALUE, {\n    set(data) {\n      setInputStateValue(data);\n      valueRef.current = data;\n    },\n\n    get() {\n      return valueRef.current;\n    }\n\n  }), Object.assign({}, rules));\n\n  if (!fieldsRef.current[name]) {\n    registerField();\n  }\n\n  useEffect$1(() => {\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    registerField();\n    return () => {\n      if (!isNameInFieldArray(fieldArrayNames, name)) {\n        unregister(name);\n      }\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [name]);\n  const props = Object.assign(Object.assign(Object.assign(Object.assign({\n    name\n  }, rest), onChange ? {\n    [onChangeName]: eventWrapper(onChange, EVENTS.CHANGE)\n  } : {\n    [onChangeName]: handleChange\n  }), isOnBlur || isReValidateOnBlur ? onBlur ? {\n    [onBlurName]: eventWrapper(onBlur, EVENTS.BLUR)\n  } : {\n    [onBlurName]: handleBlur\n  } : {}), {\n    [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value\n  });\n  return isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, Object.assign({}, props));\n};\n\nconst ErrorMessage = ({\n  as: InnerComponent,\n  errors,\n  name,\n  children\n}) => {\n  const methods = useFormContext();\n\n  const _get = get(errors || methods.errors, name, {}),\n        message = _get.message,\n        types = _get.types;\n\n  if (!message) {\n    return null;\n  }\n\n  const props = {\n    children: children ? children({\n      message,\n      messages: types\n    }) : message\n  };\n  return InnerComponent ? isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, Object.assign({}, props)) : createElement(Fragment, Object.assign({}, props));\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };","map":null,"metadata":{},"sourceType":"module"}